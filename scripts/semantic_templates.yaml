#
#  Copyright 2020 Izumi Haruta
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

##### Semantic templates for English #####

##### Unary lexical rules #####

# existential type-raising from N to NP
- category: NP
  rule: lex
  semantics: \E F1 F2. exists x. (E(\w.True,x) & F1(x) & F2(x))

- category: NP
  rule: lex
  semantics: \E F3 F4 F1 F2.E(\w.True,d1,d2,d3,I,J,\W.exists x.(W(x) & F1(x) & F2(x)),\W.exists y.(W(y) & F3(y) & F4(y)),c)
  child0_category: N[adj=true]

- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: few

- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: less

- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: not

# Unary rule for negative NPs
- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: few

- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: less

- category: NP
  rule: lex
  semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
  child_any_base: not
  

# # Unary rule for proportional NPs
# - category: NP
#   rule: lex
#   semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
#   child0_child0_child0_surf: at
#   child0_child0_child1_child0_surf: most

# - category: NP
#   rule: lex
#   semantics: \C F1 F2. - exists x. (C(\w.True,x) & F1(x) & F2(x))
#   child0_child0_child0_child0_surf: less
#   child0_child0_child0_child1_surf: than

# Unary rule for proportional CDs
- category: NP
  rule: lex
  semantics: \E F1 F2. exists x. (_many(x,E) & F1(x) & F2(x))
  child0_pos: CD

- category: NP
  rule: lex
  # semantics: \E F1 F2. exists x. (E(x) & F1(x) & F2(x))
  semantics: \E F1 F2. exists x. (_year(E,x) & F1(x) & F2(x))
  child0_pos: CD
  child0_entity: B-DATE

# existential type-raising for proper nouns from N to NP
- category: NP
  rule: lex
  # semantics: \E F1 F2. exists x. ((x = E) & F1(E) & F2(E))
  semantics: \E F1 F2. (F1(E) & F2(E))
  child0_pos: NNP

- category: S/(S\NP)
  rule: tr
  # semantics: \E F1 F2. exists x. ((x = E) & F1(E) & F2(E))
  semantics: \E W. W(E)
  child0_child0_pos: NNP

- category: NP
  rule: lex
  # semantics: \E F1 F2. exists x. ((x = E) & F1(E) & F2(E))
  semantics: \E F1 F2. exists x. (E(\w.True,x) & F1(x) & F2(x))
  child0_pos: NN

- category: NP
  rule: lex
  # semantics: \E F1 F2. exists x. ((x = E) & F1(E) & F2(E))
  semantics: \E F1 F2. (F1(E) & F2(E))
  child0_entity: B-ORG 

- category: NP
  rule: lex
  semantics: \E F1 F2. exists x. (E(\w.True,x) & F1(x) & F2(x))
  child0_entity: B-NORP

- category: NP
  rule: lex
  semantics: \E F1 F2. exists x. (E(\w.True,x) & F1(x) & F2(x))
  child0_entity: B-GPE

- category: NP
  rule: lex
  semantics: \E F1 F2. exists x. (E(\w.True,x) & F1(x) & F2(x))
  child0_entity: B-LOC

# degree expressions
- category: NP[deg=true]
  rule: lex
  semantics: \E F. F(E) 
  child0_child0_pos: CD
  #child0_child1_entity: I-QUANTITY

- category: NP
  rule: lex
  # semantics: \E F1 F2. exists x. ((x = E) & F1(E) & F2(E))
  semantics: \E F1 F2. (F1(E) & F2(E))
  child_any_pos: NNP
  child_any_base: either

- category: N\N
  rule: lex
  semantics: \V F x. (V(\G1 G2.G2(x)) & F(x))

- category: NP\NP
  rule: lex
  semantics: \V Q F1. Q(\x.(V(\F2 F3.F3(x)) & F1(x)))

- category: NP\NP
  rule: lex
  semantics: \V Q F1. Q(\x.(exists y.V(\F2 F3.F3(x,y)) & F1(x)))
  child0_category: S[pss=true]\NP

- category: NP\NP
  rule: lex
  semantics: \A Q F1. Q(\x.(A(d1,d2,d3,H,I,J,\F2 F3.F3(x)) & F1(x)))
  child0_category: S[adj=true]\NP

- category: NP/NP
  rule: lex
  semantics: \E N F1 F2.N(\x.(E(\A1 A2.A1(_u),\w.True,x) & F1(x)),F2)

- category: S[X=true]/(S[X=true]\NP)
  rule: tr
  semantics: \Q V. V(Q)


##### Binary lexical rules #####

- category: NP
  semantics: \L R F1 F2.exists x.(R(\N2._many(x,_th(N2)),x) & F1(x) & F2(x))
  child0_surf: a~lot~of
  child1_pos: NNS

- category: NP
  semantics: \L R F1 F2.exists x.(R(\N2._much(x,_th(N2)),x) & F1(x) & F2(x))
  child0_surf: a~lot~of
  child1_pos: NN

## Conjunction
- category: S\S
  rule: conj
  semantics: \L S1 S2. (S1 & S2)
  child0_surf: and

- category: NP\NP
  rule: conj
  semantics: \L Q1 Q2 F1 F2. (Q2(F1, F2) & Q1(F1, F2))
  child0_surf: and

- category: N\N
  rule: conj
  semantics: \L F1 F2 F x. (F1(F,x) & F2(F,x))
  child0_surf: and

- category: (S\NP)\(S\NP)
  rule: conj
  semantics: \L V1 V2 Q. Q(\w.True, \x.(V1(\F1 F2.F2(x)) & V2(\F1 F2.F2(x))))
  child0_surf: and

# ex. John is tall and cool.
- category: (S[adj=true]\NP)\(S[adj=true]\NP)
  rule: conj
  semantics: \L A1 A2 d1 d2 d3 H I J Q.(exists d1.A2(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2),J,Q) & exists d1.A1(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2),J,Q))
  child0_surf: and

- category: ((S|NP)|NP)|((S|NP)|NP)
  rule: conj
  semantics: \L V2 V1 Q1 Q2. Q2(\x.True,\x.Q1(\y.True,\y.(V1(\F1 F2.F2(y),\F1 F2.F2(x)) & V2(\F1 F2.F2(y),\F1 F2.F2(x)))))

- category: ((S|NP)|(S|NP))|((S|NP)|(S|NP))
  rule: conj
  semantics: \L M2 M1 V Q. (M1(V,Q) & M2(V,Q))

- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 F x. M1(M2(F,x),x)
  child0_surf: and

- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 N1 F x. (M2(N1,F,x) & M1(N1,F,x))
  child0_surf: and
  child1_child1_pos: JJ

# ex. John bought a white and blue car.
- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 N1 F x. N1(\N2.M1(\Q1 Q2.Q1(N2),\N2.M2(\Q1 Q2.Q1(N2),\w.True,x),x),x)
  child0_surf: and
  child1_pos: JJ
  child1_entity: PRE

- category: (N/N)/(N/N)
  rule: conj
  semantics: \L M1 M2 F x. M1(M2(F,x),x)
  child0_surf: and

## Disjunction
- category: S\S
  rule: conj
  semantics: \L S1 S2. (S1 & S2)
  child0_surf: or

- category: NP\NP
  rule: conj
  semantics: \L Q1 Q2 F1 F2. (Q2(F1, F2) | Q1(F1, F2))
  child0_surf: or

- category: N/N
  rule: conj
  semantics: \L F1 F2 F x. (F1(F,x) | F2(F,x))
  child0_surf: or

- category: N\N
  rule: conj
  semantics: \L F1 F2 F x. (F1(F,x) | F2(F,x))
  child0_surf: or

- category: (S\NP)\(S\NP)
  rule: conj
  semantics: \L V1 V2 Q. Q(\w.True, \x.(V1(\F1 F2.F2(x)) | V2(\F1 F2.F2(x))))
  child0_surf: or

- category: (S[adj=true]\NP)\(S[adj=true]\NP)
  rule: conj
  semantics: \L A1 A2 d1 d2 d3 H I J Q.(exists d1.A2(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2),J,Q) | exists d1.A1(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2),J,Q))
  child0_surf: or

- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 F x. (M1(F,x) | M2(F,x))
  child0_surf: or

- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 N1 F x. (M2(N1,F,x) | M1(N1,F,x))
  child0_surf: or
  child1_child1_pos: JJ

# ex. John bought a white and blue car.
- category: (N/N)\(N/N)
  rule: conj
  semantics: \L M1 M2 N1 F x. N1(\N2.(M1(\Q1 Q2.Q1(N2),\w.True,x) | M2(\Q1 Q2.Q1(N2),\w.True,x)),x)
  child0_surf: or
  child1_pos: JJ
  child1_entity: PRE

- category: (N/N)/(N/N)
  rule: conj
  semantics: \L M1 M2 F x. M1(M2(F,x),x)
  child0_surf: or

## sententce final particle
- category: S
  rule: rp
  semantics: \S D. S

## Rules for commas
- category: S
  rule: lp
  semantics: \L S. S
  child0_surf: ","

- category: N
  rule: lp
  semantics: \L R. R
  child0_surf: ","

- category: NP
  rule: rp
  semantics: \L R. L
  child0_surf: ","

- category: S\NP
  rule: rp
  semantics: \L R. L
  child0_surf: ","

- category: NP\NP
  rule: conj
  semantics: \L Q1 Q2 F1 F2. (Q2(F1, F2) & Q1(F1, F2))
  child0_surf: ","

- category: NP\NP
  rule: conj
  semantics: \L Q1 Q2 F1 F2. (Q2(F1, F2) | Q1(F1, F2))
  child0_surf: ","
  child_any_surf: or

- category: S\S
  rule: conj
  semantics: \L S. S
  child0_surf: ","

- category: (S\NP)\(S\NP)
  rule: conj
  semantics: \L V1 V2 Q. Q(\w.True, \x.(V1(\F1 F2.F2(x)) & V2(\F1 F2.F2(x))))
  child0_surf: ","

### Numeral adjectives ###

- category: N
  semantics: \L R F x.(R(\w.True,x) & _many(x,L))
  child0_pos: CD
  #child1_pos: NNS
  child1_category: N

- category: N
  semantics: \L R F x.(R(\w.True,x) & _many(x,L))
  child0_child0_pos: CD
  child1_category: N

#- category: (N/N)/(N/N)
#  # semantics: \L R d3 N F x. exists d1. N(\d2.(_many(x,d1) & $less(d3,d1)),x)
#  semantics: \L R A N F x.N(A(\A1 A2 d1 d2.A1(d,d2),F,x),x)
#  child0_surf: more
#  child1_surf: than

#- category: (N/N)/(N/N)
#  semantics: \L R d3 N F x. exists d1. N(\d2.(_many(x,d1) & $less(d1,d3)),x)
#  child0_surf: less
#  child1_surf: than

### Measure phrases ###

- category: N
  rule: fa
  # semantics: \L R. L(R)
  semantics: \L R. L
  child0_pos: CD
  child1_surf: MIPS

- category: N
  rule: fa
  # semantics: \L R. L(R)
  semantics: \L R. L
  child0_pos: CD
  child1_surf: feet

- category: N/N
  rule: fc
  semantics: \L R.$product(L,R)
  child0_pos: CD
  child1_base: "100"

# degree modifiers
- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  rule: fa
  semantics: \L R A d1 d2 d3 H I J Q.all d1.A(d1,$difference(d1,L),L,H,\A1 A2 A3 x.(-A2 -> A1(x)),\w.True,Q)
  child0_pos: CD
  child1_entity: I-QUANTITY

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)
#   rule: fa
#   # semantics: \L R A N V Q.all d1.A(N,V,$sum(d1,L),d1,\A1 A2 A3 A4 z2 z1.exists y x.(A1(x,z1) & A2(y,z2) & A4(y) -> A3(x)),Q)
#   semantics: \L R A N V Q.all d1.exists c2.A(N,V,d1,$difference(d1,L),\A1 A2 A3 A4 z2 z1.exists y x.(A1(x,z1) & A2(y,z2) & A4(y) -> A3(x)),c2,Q)
#   child0_pos: CD
#   child1_entity: I-QUANTITY

- category: (N/N)/(N[adj=true]/N)
  rule: fa
  # semantics: \L R A N F x.A(\F1 F2.N(\d2.F1(L),x),\w.True,x)
  semantics: \L R A N1 F x.exists d1 c.A(\A1 A2.N1(\N2.A1(N2),x),F,d1,$difference(d1,L),L,\A1 A2 A3.(A1 & -A2),\w.True,\W.W(x),W2,c)
  child0_pos: CD
  child1_entity: I-QUANTITY

- category: (N[adj=true]/N)/(N[adj=true]/N)
  rule: fa
  semantics: \L R A N1 F d1 d2 d3 I J W1 W2 c.all d1.exists c.A(N1,F,d1,$difference(d1,L),L,\A1 A2 A3.(A2 -> A1),\w.True,W1,W2,c)
  child0_pos: CD
  child1_entity: I-QUANTITY

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  rule: fa
  # semantics: \L R A d1 d2 d3 H R Q. exists d1. A(d1,d1,d1,\H d x.(H(x,d) & $less(L,d1)),\F1 F2 F3.F2,Q)
  semantics: \L R A d1 d2 d3 H I J Q. exists d1. A(d1,d1,d1,\H d x.H(x,d),\A1 A2 A3.A1,\W.W(L),Q)
  child0_child0_surf: more~than
  child0_child1_pos: CD
  child1_entity: I-QUANTITY

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  rule: fa
  # semantics: \L R A d1 d2 d3 H R Q. exists d1. A(d1,d1,d1,\H d x.(H(x,d) & $less(L,d1)),\F1 F2 F3.F2,Q)
  semantics: \L R A d2 d1 d3 H I J Q. -A(L,d1,d1,\H d x.H(x,d),\A1 A2 A3.A1,\w.True,Q)
  child0_child0_surf: less~than
  child0_child1_pos: CD
  child1_entity: I-QUANTITY

# - category: (S[adj=true]\NP)/(S[adj=true]\NP)
#   rule: fa
#   semantics: \L R A d1 d2 d3 H I J Q. all d1 y d2.A(d1,d2,L,\H d x.H(x,d),\A1 A2 A3 x.((-A2 -> A1(x)) & (A3(y) -> $lesseq(d2,L))),\w.True,Q)
#   child0_child0_surf: exactly
#   child0_child1_pos: CD
#   child1_entity: I-QUANTITY

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  rule: fa
  semantics: \L R A d1 d2 d3 H I J Q. exists d1. A(d1,d1,d1,\H d x.H(x,d),\A1 A2 A3 x.(A1(x) & $less($difference(L,_e),d1) & $less(d1,$sum(L,_e))),\w.True,Q)
  child0_child0_surf: about
  child0_child1_pos: CD
  child1_entity: I-QUANTITY

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  rule: fa
  semantics: \L R A d1 d2 d3 H I J Q.all d1.A(d1,$difference(d1,_e),d3,H,\A1 A2 A3 x.(-A2 -> A1(x)),J,Q)
  child0_surf: very
  child1_surf: much

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/(NP\NP))/N
#   rule: ba
#   semantics: \L R.R(\d.$sum(d,L))
#   child0_pos: CD
#   child1_surf: more

### Adverbs ###

- category: (NP/N)/(N/N)
  rule: fa
  # semantics: \L R d N F1 F2.exists x.(N(x) & _many(x,d) & F1(x) & F2(x))
  semantics: \L R d N F1 F2.exists x.(N(\w.True,x) & _many(x,d) & F1(x) & F2(x))
  child0_surf: at
  child1_surf: least

- category: NP/NP
  rule: fa
  semantics: \L R X. X
  child0_surf: at
  child1_surf: least

- category: NP/N
  rule: fc
  semantics: \L R. L 
  child0_surf: a
  child1_surf: few

- category: NP/N
  rule: fa
  # semantics: \L R N F1 F2. exists d.(L($product(d,2),N,F1,F2) & -L(d,N,F1,-F2))
  semantics: \L R N F1 F2. all d1.(L(d1,N,F1,-F2) -> L(d1,N,F1,F2))
  child0_category: (NP/N)/(N/N)
  child1_surf: half

- category: (N/N)/(N/N)
  rule: ba
  semantics: \L R d2 N1 F x.exists d1.N1(\d.(_many(x,d1) & $less(d2,d1)),x)
  child0_child1_surf: more
  child1_surf: than
  child0_category: S[adj=true]\NP

- category: (N/N)/(N/N)
  rule: ba
  semantics: \L R d1 N1 F x. N1(\d2._many(x,d1),x)
  child0_child1_surf: less
  child1_surf: than
  child0_category: S[adj=true]\NP

- category: (N/N)/(N/N)
  rule: ba
  semantics: \L R d1 N1 F x. N1(\d2._many(x,d1),x)
  child0_child1_surf: fewer
  child1_surf: than
  child0_category: S[adj=true]\NP
  
- category: N
  rule: fa
  semantics: \L R F x. exists d1.(_many(x,d1) & $less(R,d1))
  child0_child0_surf: more
  child0_child1_surf: than
  child1_pos: CD

- category: N
  rule: fa
  semantics: \L R F x.exists d1.(_many(x,d1) & $less(d1,R))
  child0_child0_surf: less
  child0_child1_surf: than
  child1_pos: CD

# one or more
- category: N/N
  rule: ba
  semantics: \L R P F x. (P(F,x) & _many(x,1))
  child0_surf: one
  child1_child0_surf: or
  child1_child1_surf: more

- category: N/N
  rule: fa
  #semantics: \L R N F x. (N(\w1 w2.True,x) & _many(x,R))
  semantics: \L R N1 F x. exists d1. N1(\d.(_many(x,d1) & $less(R,d1)),x)
  #child0_pos: RB
  child0_child0_surf: more
  child0_child1_surf: than
  child0_category: (N/N)/(N/N)
  child1_pos: CD

- category: N/N
  rule: fa
  # semantics: \L R N F x. (N(\w1 w2.True,x) & _many(x,R))
  # semantics: \L R N1 F x. exists d1. N1(\d.(_few(x,d1) & $less(d1,R)),x)
  semantics: \L R N1 F x. N1(\d._many(x,R),x)
  #child0_pos: RB
  child0_child0_surf: less
  child0_child1_surf: than
  child0_category: (N/N)/(N/N)
  child1_pos: CD

- category: N
  rule: fa
  semantics: \L R F x. exists d1.(_many(x,d1) & $less(R,d1))
  child0_child0_surf: more
  child0_child1_surf: than
  child1_pos: CD

- category: N
  rule: fa
  semantics: \L R F x.exists d1.(_many(x,d1) & $less(d1,R))
  child0_child0_surf: less
  child0_child1_surf: than
  child1_pos: CD

- category: N/N
  rule: fa
  semantics: \L R N1 F x. (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: exactly
  child1_pos: CD

- category: N/N
  rule: fa
  semantics: \L R N1 F x . (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: just
  child1_pos: CD

- category: N/N
  rule: fa
  semantics: \L R N1 F x. (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: only
  child1_pos: CD

- category: (N/N)\(N/N)
  rule: conj
  #semantics: \L R P F x. (P(F,x) & _many(x,1))
  semantics: \L R X. X
  child0_surf: or
  child1_surf: more

- category: S[adj=true]\NP
  rule: fa
  semantics: \L R d1 d2 d3 H I J.L(R(d1,d2,d3,H,I,J))
  child0_pos: RB
  child1_pos: JJ
  child1_entity: PRE

- category: N/N
  rule: fa
  semantics: \L R N1 F x. (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: exactly
  child1_pos: CD

- category: N/N
  rule: fa
  semantics: \L R N1 F x . (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: just
  child1_pos: CD

- category: N/N
  rule: fa
  semantics: \L R N1 F x. (N1(\w.True,x) & all d1. (_many(x,d1) <-> (d1 = R)))
  child0_surf: only
  child1_pos: CD

## the + N ##

- category: NP
  rule: fa
  semantics: \L R F1 F2. (F1(R) & F2(R))
  child0_surf: the
  child1_pos: NNP

##### Noun Phrases and Pronouns #####

## Common nouns
- category: N
  # semantics: \E x. E(x)
  # semantics: \E. E
  semantics: \E F x. (E(x) & F(E))

- category: N
  semantics: \E F x.(x = x)
  surf: one
  
## Proper nouns
- category: N
  semantics: \E. E
  pos: NNP

- category: N
  # semantics: \E x. E(x)
  # semantics: \E. E
  semantics: \E F x. (E(x) & F(E))
  entity: B-NORP

- category: N
  semantics: \E F x. (E(x) & F(E))
  entity: B-LOC

- category: N
  semantics: \E F x. (E(x) & F(E))
  entity: B-GPE

- category: N
  semantics: \E. E
  entity: B-ORG

- category: N
  semantics: \E. E
  pos: CD 

# default existential interpretation
- category: NP
  semantics: \E F1 F2. exists x. (F1(x) & F2(x))

- category: NP
  semantics: \E F1 F2. forall x. (_people(x) -> (F1(x) -> F2(x)))
  surf: everyone

- category: NP
  semantics: \E F1 F2. forall x. (_people(x) -> (F1(x) -> F2(x)))
  surf: everybody

- category: NP
  # semantics: \E F1 F2. (exists x. _people(x) & forall x. (_people(x) -> - F2(x)))
  semantics: \E F1 F2. -exists x. (F1(x) & F2(x))
  surf: nobody

- category: NP
  semantics: \E F1 F2. forall x. (F1(x) -> F2(x))
  surf: all

- category: NP
  semantics: \E F1 F2. forall x. (F1(x) -> F2(x))
  surf: each

- category: NP
  # semantics: \E F1 F2. exists x. (_many(x,2) & F1(x) & F2(x))
  semantics: \E F1 F2. exists x. (F1(x) & F2(x))
  surf: both

- category: NP
  # semantics: \E F1 F2. (exists x. (F1(x) & _many(x,2)) & forall x. (F1(x) -> - F2(x)))
  semantics: \E F1 F2. (exists x. F1(x) & forall x. (F1(x) -> - F2(x)))
  surf: neither


##### Determiners #####

# default existential interpretation
- category: NP/N
  # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  pos: DT

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  pos: PRP$

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> F3(x)))
  semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> F3(x)))
  surf: every

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> F3(x)))
  semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> F3(x)))
  surf: all

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> F3(x)))
  semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> F3(x)))
  surf: each

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> F3(x)))
  semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> F3(x)))
  surf: any

- category: NP[npi=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> F3(x)))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: any

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: some

- category: NP[nb=true]/N
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: another

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  base: a

# - category: NP[nb=true]/N
#   # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
#   semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
#   surf: an

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. exists x. (_many(x,2) & F1(x) & F2(x) & F3(x))
  # semantics: \E F1 F2 F3. exists x. (F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: both

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. (exists x. (F1(x) & _many(x,2)) & forall x. (F1(x) -> (F2(x) -> - F3(x))))
  # semantics: \E F1 F2 F3. (exists x. F1(x) & forall x. (F1(x) -> (F2(x) -> - F3(x))))
  semantics: \E F1 F2 F3. (exists x. F1(\w.True,x) & forall x. (F1(\w.True,x) -> (F2(x) -> - F3(x))))
  surf: neither

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> - F3(x)))
  # semantics: \E F1 F2 F3. forall x. (F1(\w.True,x) -> (F2(x) -> - F3(x)))
  semantics: \E F1 F2 F3. -exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: "no"

#- category: NP[nb=true]/N
#  semantics: \E F1 F2 F3. forall x. (F1(x) -> (F2(x) -> - F3(x)))
#  surf: few

- category: NP[nb=true]/N
  # semantics: \E F1 F2 F3.exists x.(F1(x) & F2(x) & F3(x))
  semantics: \E F1 F2 F3. exists x. (F1(\w.True,x) & F2(x) & F3(x))
  surf: a~few

- category: (NP/N)/(N/N)
  semantics: \E d N F1 F2.-exists x.(N(\w.True,x) & _many(x,$sum(d,1)) & F1(x) & F2(x))
  surf: at~most

- category: NP/NP
  semantics: \E Q F1 F2. forall x. (Q(\w.True, \y.((x = y) & F1(y))) -> F2(x))
  surf: all

- category: NP/NP
  semantics: \E A F1 F2.A(\x.F1(x),F2)
  surf: some

- category: NP\NP
  semantics: \E Q F1 F2. forall x. (Q(\w.True, \y.((x = y) & F1(y))) -> F2(x))
  surf: all

- category: NP|NP
  semantics: \E Q. Q
  surf: such

- category: NP|NP
  semantics: \E X.X
  surf: of

##### Adverbs #####

- category: (N/N)/(N/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(\A1 A2.N1(\N2.(A1(N2) & E(x)),x),F,x)

- category: (N/N)/(N[adj=true]/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(\A1 A2.N1(\N2.(A1(N2) & E(x) & (d1 = _th(N2))),x),F,d1,d1,d1,\A1 A2 A3.A1,\w.True,\W.W(x),W2,c)

- category: (N/N)/(N/N) 
  semantics: \E X. X
  surf: at

- category: (N/N)/(N[adj=true]/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(N1,F,d1,d1,d1,\A1 A2 A3.A1,\W.W(_e),\W.W(x),W2,c)
  surf: very

- category: (N/N)/(N[adj=true]/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(N1,F,d1,d1,d1,\A1 A2 A3.A1,\w.True,\W.W(x),W2,c)
  surf: not

- category: (N/N)/(N[adj=true]/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(\A1 A2.N1(\N2.(A1(N2) & (d1 = _th(N2))),x),F,d1,d1,d1,\A1 A2 A3.A1,\w.True,\W.W(x),W2,c)
  surf: pos

- category: (N/N)/(N[adj=true]/N) 
  semantics: \E A N1 F x.exists d1.exists c.A(N1,F,d1,d1,d1,\A1 A2 A3.A1,\W.W(_e),\W.W(x),W2,c)
  surf: so

- category: (N[adj=true]/N)/(N[adj=true]/N) 
  semantics: \E A N1 F d1 d2 d3 I J W1 W2 c.exists d1.exists c.A(N1,F,d1,d1,d1,\A1 A2 A3.(A1 & -A2),\w.True,W1,W2,c)
  surf: dgr

- category: (N[adj=true]/N)/(N[adj=true]/N) 
  semantics: \E A N1 F d1 d2 d3 I J W1 W2 c.all d1.exists c.A(N1,F,$sum(d1,_e),d1,d1,\A1 A2 A3.(A2 -> A1),\w.True,W1,W2,c)
  surf: much

# - category: (N[adj=true]/N)/(N[adj=true]/N) 
#   semantics: \E A N1 F d1 d2 d3 I J W1 W2 c.all d1.exists c.A(N1,F,$sum(d1,_e),d1,d1,\A1 A2 A3.(A2 -> A1),\w.True,W1,W2,c)
#   surf: many

# ex. John is a more expensive car than Bob is.
- category: (N[adj=true]/N)/(N[adj=true]/N) 
  semantics: \E A N1 F d1 d2 d3 I J W1 W2 c.A(\A1 A2.N1(A1,A2),F,d1,d2,d3,\A1 A2 A3.W2(\y.(N1(\w.True,y) & I(A1,A3(y),A2))),J,W1,W2,c)
  surf: more

- category: (S\NP)\(S\NP)
  semantics: \E V Q. Q(\w.True, \x.(E(x) & V(\F1 F2.F2(x))))

- category: (S\NP)\(S\NP)
  semantics: \E V Q. Q(\w.True, \x.exists d1.(E(x,d1) & V(\F1 F2.F2(x))))
  pos: JJ

- category: (S\NP)/(S\NP)
  semantics: \E V Q. exists d.Q(\w.True, \x.(E(x,d) & V(\F1 F2.F2(x))))
  pos: JJ

- category: (S\NP)\(S\NP)
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: ever

- category: (S\NP)\(S\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: n't

- category: (S\NP)/(S\NP)
  semantics: \E V Q. Q(\w.True, \x.(E(x) & V(\F1 F2.F2(x))))

- category: (S[pss=true]|NP)|(S[adj=true]|NP)
  semantics: \E A Q. Q(\w.True, \y x.(E(x,y) & A(d1,d2,d3,H,I,J,\F1 F2.F2(y))))

- category: (S\NP)/(S\NP)
  semantics: \E V Q. Q(\w.True, \x.(__have(x) & V(\F1 F2.F2(x))))
  surf: have
  pos: VBP

- category: (S[adj=true]\NP)/(S[to=true]\NP)
  semantics: \E T d1 d2 d3 H I J Q.exists d1.T(\F1 F2.Q(F1,\x.(E(x,d1) & F2(x))))
  pos: JJ

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  # semantics: \E A d1 d2 d3 H I J Q.exists d1.A(d1,d1,d1,\w.True,\A1 A2 A3 x.(E(x,d1) & A1(x)),\w.True,Q)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.A(d1,d1,d1,\w.True,\A1 A2 A3 x.A1(x),\w.True,\F1 F2.Q(F1,\x.(E(x,d1) & F2(x))))
  pos: JJ

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.(A(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2 & E(x)),J,Q))
  pos: RB
  
# John is deg taller than Bob .
- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.A(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & A2),J,Q)
  surf: dgr

# John is pos tall .
- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.A(d1,d1,_th(_u),H,\A1 A2 A3 x.(A1(x) & -A2),J,Q)
  surf: pos

# ex. John is deg2 as tall as Bob .
- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.all d1.A(d1,d1,_th(_u),H,\A1 A2 A3 x.(A2 -> A1(x)),J,Q)
  surf: dgr2

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  # semantics: \E A d1 d2 d3 H R Q.exists d1.A(d1,d1,d1,\H d x.(H(x,d) & $less(_th(_u),d1)),\F1 F2 F3.F2,Q)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.A(d1,d1,d1,\w.True,\A1 A2 A3 x.A1(x),\W.W(_e),Q)
  surf: very

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  # semantics: \E A d1 d2 d3 H R F1 F2 Q.A($product(d1,_2),d2,_2,H,R,F1,F2,Q)
  semantics: \E A d1 d2 d3 H I J Q.all d1.A(d1,$difference(d1,_e),d3,H,\A1 A2 A3 x.(-A2 -> A1(x)),J,Q)
  surf: much

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)
#   semantics: \E A N V Q.all d1.exists c.A(N,V,$sum(d1,e),d1,\A1 A2 A3 A4 z2 z1.exists y x.(A1(x,z1) & A2(y,z2) & A4(y) -> A3(x)),c,Q)
#   surf: much

# ex. John won many more orders than Bob.
# - category: (((S\NP)\((S\NP)/NP))/N)/(((S\NP)\((S\NP)/NP))/N)
- category: (NP[adj=true]/N)/(NP[adj=true]/N)
  # semantics: \E A N V Q.all d1.exists c.A(N,V,$sum(d1,_e),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  semantics: \E A N V d1 d2 I c Q.all d1.exists c.A(N,V,$sum(d1,_e),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  surf: many

# John won dgr more orders than Bob .
# - category: (((S\NP)\((S\NP)/NP))/N)/(((S\NP)\((S\NP)/NP))/N)
- category: (NP[adj=true]/N)/(NP[adj=true]/N)
  # semantics: \E A N V Q.exists d1.A(N,V,d1,d1,\A1 A2 z2 z1.exists y x.(A1(x,\W.W,z1) & A2(y,\W.-W,z2)),Q)
  # semantics: \E A N V Q.exists d1.exists c.A(N,V,d1,d1,\A1 A2 z2 z1.(exists x.A1(x,z1) & -exists y.A2(y,z2)),c,Q)
  semantics: \E A N V d1 d2 I c Q.exists d1.exists c.A(N,V,d1,d1,\A1 A2 z2 z1.(exists x.A1(x,z1) & -exists y.A2(y,z2)),c,Q)
  surf: dgr

# John won dgr2 as many orders as Bob .
# - category: (((S\NP)\((S\NP)/NP))/N)/(((S\NP)\((S\NP)/NP))/N)
- category: (NP[adj=true]/N)/(NP[adj=true]/N)
  # semantics: \E A N V Q.all d1.exists c.A(N,V,d1,d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  semantics: \E A N V d1 d2 I c Q.all d1.exists c.A(N,V,d1,d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  surf: dgr2

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q. A(d1,d2,d3,H,\A1 A2 A3.I(A1,A3,A2),J,Q)
  surf: more
  pos: RBR

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.A(d1,d1,d1,H,\A1 A2 A3.I(\x.-A1(x),-A3,A2),J,Q)
  surf: less

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q. A(d1,d2,d3,H,\A1 A2 A3.I(A1,A3,A2),J,Q)
  surf: as
  pos: RB

# ex. John is dgr as expensive car as Bob .
- category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(N/N)
  semantics: \E A N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & A(N1,F,x,d1,d2,d3,H,\A1 A2 A3.True,J,c)),\y z4.(F2(z4,y) & N1(\w.True,y)),\x.A(\w1 w2.True,F,x,d1,d2,d3,H,\A1 A2 A3.A1(x),\w.True,c),\y.A(\w1 w2.True,F,y,d1,d2,d3,\H d.H(y,d),\A1 A2 A3.A3,J,c))))
  surf: as

# ex. John is dgr more expensive car than Bob .
- category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(N/N)
  semantics: \E A N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & A(N1,F,x,d1,d2,d3,H,\A1 A2 A3.True,J,c)),\y z4.(F2(z4,y) & N1(\w.True,y)),\x.A(\w1 w2.True,F,x,d1,d2,d3,H,\A1 A2 A3.A1(x),\w.True,c),\y.A(\w1 w2.True,F,y,d1,d2,d3,\H d.H(y,d),\A1 A2 A3.A3,J,c))))
  surf: more

- category: (S/S)/NP
  semantics : \E Q S. (E(Q(\w.True, \w.True),S) & S)

- category: ((S\NP)\(S\NP))/S[dcl=true]
  semantics: \E S V Q. Q(\w.True, \x.(S & V(\F1 F2.F2(x)) & E(S, V(\F1 F2.F2(x)))))

- category: ((S\NP)\(S\NP))/((S\NP)\(S\NP))
  semantics: \E A V Q. Q(\w.True, \x.(A(V)(\F1 F2.(F2(x) & E(x)))))

##### Modifiers #####
- category: N/N
  semantics: \E N1 F x. N1(\N2.(E(x) & F(N2)),x)

- category: N/N
  semantics: \E N1 F x. N1(\N2.F(N2),x)
  surf: none

- category: N/N
  semantics: \E X. X
  surf: at

## ex. bug # 33_33 (fracas-098) ##

- category: N/N
  semantics: \E N F x.(E(x) & _num(N,x) & F(N))
  surf: "#"

- category: NP/N
  semantics: \E N F1 F2. exists d. (exists x.(N(\w.True,x) & F1(x) & F2(x) & _many(x,d)) & -exists y.(N(\w.True,y) & F1(y) & -F2(y) & _many(y,d)))
  surf: most

- category: N\N
  semantics: \E F x. (E(x) & F(x))

- category: (N/N)\NP
  semantics: \E Q F x. Q(\w.True, \y.(E(x,y) & F(x)))


##### Prepositions #####

- category: (NP\NP)/NP
  semantics: \E Q1 Q2 F1. Q2(\x.(Q1(\w.True, \y.E(x,y)) & F1(x)))

- category: (N\N[adj=true])/NP
  # semantics: \E Q1 A F1 F2.A(\w.True,\x.Q1(\w.True,\y.(y = x)),F1,F2)
  semantics: \E Q1 A F x.A(F,d1,d2,d3,I,J,\W.W(x),\W.exists y.Q1(\w.True,\z.(W(y) & (z = y))),c)
  surf: than

- category: (N\N[adj=true])/NP
  # semantics: \E Q1 A F1 F2.A(\w.True,\x.Q1(\w.True,\y.(y = x)),F1,F2)
  semantics: \E Q1 N F x.N(F,d1,d2,d3,I,J,\W.W(x),\W.exists y.Q1(\w.True,\z.(W(y) & (z = y))),c)
  surf: as

- category: (NP|NP)|NP
  semantics: \E Q1 Q2 F1. Q2(\x.(Q1(\w.True, \y.(x = y)) & F1(x)))
  surf: of

- category: (NP|NP)|NP
  semantics: \E Q1 Q2 F1. Q2(\x.(Q1(\w.True, \y.(x = y)) & F1(x)))
  surf: for

- category: PP/NP
  semantics: \E Q x. Q(\w.True, \y.E(x,y))

- category: PP/(S[ng=true]\NP)
  semantics: \E V x. V(\F1 F2.F2(x))

- category: (NP\NP)/S
  semantics: \E S Q F1 F2. (Q(F1,F2) & S)

- category: ((S|NP)|(S|NP))|PP
  semantics: \E Q1 V Q2. Q2(\w.True, \x.(Q1(x) & E(x) & V(\F1 F2.F2(x))))

- category: ((S[pss=true]\NP)\(S[pss=true]\NP))/PP
  semantics: \E Q1 V Q2. Q2(\w.True, \x y.(Q1(x) & E(x) & V(\F1 F2.F2(x,y))))

- category: ((S\NP)\(S\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, \x.Q1(\w.True, \y.(E(x,y) & V(\F1 F2.F2(x)))))

- category: ((S[pss=true]\NP)\(S[pss=true]\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, V(\F1 F2 y x.(F2(y,x) & Q1(\y.E(x,y),\w.True))))

- category: ((S[pss=true]\NP)\(S[pss=true]\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, \x y.Q1(\w.True, \y.V(\F1 F2.F2(x,y))))
  surf: by

- category: ((S\NP)\(S\NP))/(S[ng=true]\NP)
  semantics: \E V1 V2 Q. Q(\w.True, \x.V1(\F1 F2.(V2(\G1 G2.G2(x)) & F2(x))))

- category: ((S\NP)\(S\NP))/(S[ng=true]\NP)
  semantics: \E V1 V2 Q. Q(\w.True, \x.V1(\F1 F2.(V2(\G1 G2.G2(x)) & -F2(x))))
  surf: without

- category: (NP\NP)/(S[ng=true]\NP)
  semantics: \E V Q F. Q(\x.V(\G1 G2.(G2(x) & F(x))))

- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/NP
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,H,I,\w.True,Q2)

- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/NP
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\H d.Q1(\w.True,\y.-H(y,d)),I,\w.True,Q2)
  surf: than

# differential "than"
- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/NP[deg=true]
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\y d.True,I,Q1,Q2)
  surf: than

# deletion "than"
- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/(S[dcl=true]/(S[dcl=true]\NP))
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\H d.Q1(\X.X,\w.True,\y.-H(y,d)),I,\w.True,Q2)
  surf: than

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP)))/NP
- category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\NP[adj=true])/NP
  # semantics: \E Q1 A V Q2. A(V,\A1 A2.Q2(A1,\z1.Q1(\w.True,\x.A2(x,z1))))
  semantics: \E Q1 A V Q2. A(V,d1,d2,I,c,\A1 A2.Q2(A1,\z1.Q1(\w.True,\x.A2(x,z1))))
  surf: than

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP)))/S[dcl=true]
- category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\NP[adj=true])/S[dcl=true]
  semantics: \E Q1 A V Q2. A(V,d1,d2,I,c,\A1 A2.Q2(A1,\z1.Q1(\w.True,\x.A2(x,z1))))
  surf: than

- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/NP
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\H d.Q1(\w.True,\y.H(y,d)),I,\w.True,Q2)
  surf: as

- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/NP[deg=true]
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\y d1.Q1(\d2.(d1 = d2)),I,\w.True,Q2)
  surf: as

# deletion "as"
- category: ((S[adj=true]\NP)\(S[adj=true]\NP))/(S[dcl=true]/(S[dcl=true]\NP))
  semantics: \E Q1 A d1 d2 d3 H I J Q2. A(d1,d2,d3,\H d.Q1(\X.X,\w.True,\y.H(y,d)),I,\w.True,Q2)
  surf: as

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP)))/NP
- category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))\NP[adj=true])/NP
  semantics: \E Q1 A V Q2.A(V,d1,d2,I,c,\A1 A2.Q2(A1,\z1.Q1(\w.True,\x.A2(x,z1))))
  surf: as
  

##### Verb phrases #####

## intransitive verbs
- category: S\NP
  semantics: \E Q. Q(\w.True, \x.E(x))

- category: S\NP
  # semantics: \E Q. Q(\w.True, \x.(Prog(E(x))))
  semantics: \E Q. Q(\w.True, \x.(E(x)))
  pos: VBG

- category: S\NP
  semantics: \E X.X
  base: do

- category: S[pss=true]\NP
  semantics: \E Q. Q(\w.True, \y x.E(x,y)) 

#- category: S\NP
#  semantics: \E X.X
#  base: be

## transitive verbs
- category: (S\NP)/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.E(x,y)))

- category: (S[pss=true]|NP)|NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.E(x,y)))

- category: (S\NP)/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.E(y)))
  pos: JJ
  entity: PRE

- category: (S\NP)/NP
  # semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.Prog(E(x,y))))
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.E(x,y)))
  pos: VBG

- category: (S\NP)/NP
  # semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.Prog(E(x,y))))
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.(x = y)))
  base: do

- category: ((S\NP)/PP)/NP
  semantics: \E Q1 F Q2. Q2(\w.True, \x.(Q1(\w.True, \y.E(x,y)) & F(x)))

- category: (S[dcl=true]\NP)/(S[to=true]\NP)
  # semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.E(x,F2(x))))
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.(E(x) & F2(x))))

- category: (S[dcl=true]\NP)/(S[to=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.E(x,F2(x))))
  base: manage

- category: (S[dcl=true]\NP)/(S[to=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.E(x,F2(x))))
  base: fail

- category: (S[dcl=true]\NP)/(S[to=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.E(x,F2(x))))
  base: try

- category: ((S\NP)/(S[ng=true]\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, \x.E(x,Q1(\w.True, \y.V(\F1 F2.F2(y)))))

- category: ((S[dcl=true]\NP)/(S[to=true]\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, \x.E(x,Q1(\w.True, \y.V(\F1 F2.F2(y)))))

- category: ((S\NP)/NP)/NP
  semantics: \E Q1 Q2 Q3. Q3(\w.True,\x1.Q2(\w.True,\x2.Q1(\w.True,\x3.E(x1,x2,x3))))

- category: (S\NP)/PP
  semantics: \E F Q. Q(\w.True, \x.(E(x) & F(x)))

- category: (S[adj=true]|NP)|PP
  semantics: \E Q1 d1 d2 d3 H I J Q2. exists d1.Q2(\w.True, \x.(E(x,d1) & Q1(x)))

- category: (S[pss=true]\NP)/PP
  semantics: \E F Q. Q(\w.True, \y x.(E(x,y) & F(y)))

- category: (S[pss=true]|NP)|(PP|NP)
  semantics: \E Q1 Q2.Q2(\w.True, \y x.(E(x,y) & Q1(\F1 F2.F2(y),x)))

- category: (S\NP)/S
  semantics: \E S Q. Q(\w.True, \x.E(x,S))

- category: (S\NP)/S[em=true]
  semantics: \E S Q. Q(\w.True, \x.E(x,S))
  base: know

- category: (S\NP)/S[em=true]
  semantics: \E S Q. Q(\w.True, \x.E(x,S))
  base: manage

- category: (S\NP)/S[em=true]
  semantics: \E S Q. Q(\w.True, \x.E(x,S))
  base: fail

- category: (S\NP)/S[qem=true]
  semantics: \E S Q. Q(\w.True, \x.E(x,S))

- category: ((S[dcl=true]\NP)/(S[b=true]\NP))/NP
  semantics: \E Q1 V Q2. Q2(\w.True, \x.Q1(\w.True, \y.(E(x,y) & V(\F1 F2.F2(y)))))


##### Copula #####

- category: (S\NP)/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.(x = y)))
  base: be

- category: (S|NP[thr=true])|NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.True))
  base: be

- category: (S[dcl=true]\NP)/PP
  semantics: \E F Q. Q(\w.True, F)
  base: be

- category: (S\NP)/(S\NP)
  semantics: \E X.X
  base: be

- category: (S\NP)/(S[pss=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.exists y.V(\F1 F2.F2(x,y)))

- category: (S\NP)/(S[adj=true]\NP)
  semantics: \E A Q. A(d1,d2,d3,H,I,\w.True,Q)
  base: be

- category: (S\NP)/(S[adj=true]\NP)
  semantics: \E Q1 Q2.Q2(\w.True,\x.-Q1(d1,d2,d3,H,I,\w.True,\F1 F2.F2(x)))
  surf: isn't

# ex. it is true that ...
- category: ((S[dcl=true]\NP[expl=true])/S[em=true])/(S[adj=true]\NP)
  semantics: \E A S Q. A(d1,d2,d3,H,I,J,\F1 F2.Q(F1,\x.F2(S)))

- category: (S[dcl=true]\(S[adj=true]\NP))/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \y.E(x,y)))


##### Negation #####

- category: (S|NP)|(S|NP) 
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: not

- category: (S|NP)|(S|NP) 
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  surf: never

- category: (S[pss=true]|NP)|(S[pss=true]|NP) 
  semantics: \E V Q. Q(\w.True,  \y x.-V(\F1 F2.(F2(y,x) & E(y))))
  

#### Adjectives ####

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,d1) & J(\d4.$less(d1,d4))),-(d1 = d3),H(E,d2)))
  pos: JJ
  entity: NEG

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,d1) & J(\d4.$less(d4,d1))),-(d1 = d3),H(E,d2)))
  pos: JJ
  entity: POS

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,_np(_u,d1)) & J(\d4.$less(d1,d4))),-(d1 = d3),H(E,_np(_u,d2))))
  pos: JJ
  entity: NEG-INT

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,_np(_u,d1)) & J(\d4.$less(d4,d1))),-(d1 = d3),H(E,_np(_u,d2))))
  pos: JJ
  entity: POS-INT

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,\x.E(x))
  pos: JJ
  entity: PRE

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,\x.E(x))
  entity: B-NORP

- category: S[adj=true]\NP
  semantics: \E d2 d1 d3 H I J Q. Q(\w.True,I(\x.(E(x,d1) & J(\d4.$less(d1,d4))),H(E,d2),-(d1 = d3)))
  pos: JJR
  entity: NEG

# - category: S[adj=true]\NP
#   semantics: \E d2 d1 d3 H I J Q. Q(\w.True,I(\x.(little(x,d1) & J(\d4.$less(d1,d4))),H(E,d2),-(d1 = d3)))
#   pos: JJR
#   surf: less

- category: S[adj=true]\NP
  semantics: \E d2 d1 d3 H I J Q. Q(\w.True,I(\x.(few(x,d1) & J(\d4.$less(d1,d4))),H(E,d2),-(d1 = d3)))
  pos: JJR
  surf: fewer

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,d1) & J(\d4.$less(d4,d1))),H(E,d2),-(d1 = d3)))
  pos: JJR
  entity: POS

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(many(x,d1) & J(\d4.$less(d4,d1))),H(E,d2),-(d1 = d3)))
  pos: JJR
  surf: more

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,_np(_u,d1)) & J(\d4.$less(d1,d4))),H(E,_np(_u,d2)),-(d1 = d3)))
  pos: JJR
  entity: NEG-INT

- category: S[adj=true]\NP
  semantics: \E d1 d2 d3 H I J Q. Q(\w.True,I(\x.(E(x,_np(_u,d1)) & J(\d4.$less(d4,d1))),H(E,_np(_u,d2)),-(d1 = d3)))
  pos: JJR
  entity: POS-INT

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\w.True,x) & I((E(x,d1) & J(\d4.$less(d1,d4))),-(d1 = d3),\y.E(y,d2))))
  pos: JJ
  entity: NEG

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\w.True,x) & I((_many(x,d1) & J(\d4.$less(d1,d4))),-(d1 = d3),\y.E(y,d2))))
  pos: JJ
  surf: few

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\w.True,x) & I((E(x,d1) & J(\d4.$less(d4,d1))),-(d1 = d3),\y.E(y,d2))))
  pos: JJ
  entity: POS

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\N2.(c = N2),x) & I((E(x,_np(c,d1)) & J(\d4.$less(d1,d4))),-(d1 = d3),\y.E(y,_np(c,d2)))))
  pos: JJ
  entity: NEG-INT

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\N2.(c = N2),x) & I((E(x,_np(c,d1)) & J(\d4.$less(d4,d1))),-(d1 = d3),\y.E(y,_np(c,d2)))))
  pos: JJ
  entity: POS-INT

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\w.True,x) & W2(\y.(N1(\w.True,y) & I((E(x,d1) & J(\d4.$less(d1,d4))),E(y,d2),(d1 = d3))))))
  pos: JJR
  entity: NEG

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\w.True,x) & W2(\y.(N1(\w.True,y) & I((E(x,d1) & J(\d4.$less(d4,d1))),E(y,d2),(d1 = d3))))))
  pos: JJR
  entity: POS

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.I(W1(\x.(N1(\w.True,x) & _many(x,d1) & J(\d4.$less(d1,d4)))),W2(\y.(_many(y,d2) & N1(\w.True,y))),(d1 = d3))
  pos: JJR
  surf: more
  
- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\N2.(c = N2),x) & W2(\y.(N1(\w.True,y) & I((E(x,_np(c,d1)) & J(\d4.$less(d1,d4))),E(y,_np(c,d2)),(d1 = d3))))))
  pos: JJR
  entity: NEG-INT

- category: N[adj=true]/N
  semantics: \E N1 F d1 d2 d3 I J W1 W2 c.W1(\x.(N1(\N2.(c = N2),x) & W2(\y.(N1(\w.True,y) & I((E(x,_np(c,d1)) & J(\d4.$less(d4,d1))),E(y,_np(c,d2)),(d1 = d3))))))
  pos: JJR
  entity: POS-INT

- category: N/N
  semantics: \E N1 F x. N1(\N2.(E(x) & F(N2)),x)
  entity: PRE

- category: N/N
  semantics: \E N1 F x. exists y.N1(\N2.(E(y,x) & F(N2)),x)
  pos: VBN

- category: N/N
  semantics: \E X. X
  surf: other

# - category: N/N
#   semantics: \E N1 F x. E(N1(F,x))
#   surf: former

- category: N/N
  semantics: \E N1 F x. E(N1(F,x))
  surf: former
  pos: JJ
  entity: N-SUB

- category: N/N
  semantics: \E N1 F x. N1(\N2.(E(x) & F(N2)),x)
  entity: B-NORP

# - category: ((S\NP)\((S\NP)/NP))/N
#   semantics: \E N1 V d2 d1 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\w.True,x)),\y z2.(F2(z2,y) & N1(\w.True,y)),\x.E(x,d1),\y.E(y,d2))))
#   pos: JJR
#   entity: NEG

# - category: ((S\NP)\((S\NP)/NP))/N
#   semantics: \E N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\w.True,x)),\y z2.(F2(z2,y) & N1(\w.True,y)),\x.E(x,d1),\y.E(y,d2))))
#   pos: JJR
#   entity: POS

# ex. John won more orders than Bob.
# - category: ((S\NP)\((S\NP)/NP))/N
- category: NP[adj=true]/N
  # semantics: \E N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\w.True,x)),\y z2.(F2(z2,y) & N1(\w.True,y)),\x._many(x,d1),\y._many(y,d2))))
  semantics: \E N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\w.True,x) & _many(x,d1)),\y z2.(F2(z2,y) & N1(\w.True,y) & _many(y,d2)))))
  surf: more

# - category: ((S\NP)\((S\NP)/NP))/N
#   semantics: \E N1 V d2 d1 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\N2.(c = N2),x)),\y z2.(F2(z2,y) & N1(\w.True,y)),\x.E(x,_np(c,d1)),\y.E(y,_np(c,d2)))))
#   pos: JJR
#   entity: NEG-INT

# - category: ((S\NP)\((S\NP)/NP))/N
#   semantics: \E N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\N2.(c = N2),x)),\y z2.(F2(z2,y) & N1(\w.True,y)),\x.E(x,_np(c,d1)),\y.E(y,_np(c,d2)))))
#   pos: JJR
#   entity: POS-INT

# - category: ((S\NP)\((S\NP)/NP))/N
- category: NP[adj=true]/N
  semantics: \E N1 V d1 d2 I c Q.V(\F1 F2 y.F2(y),\F1 F2.Q(F1,I(\x z1.(F2(z1,x) & N1(\w.True,x) & _many(x,d1)),\y z2.(F2(z2,y) & N1(\w.True,y) & _many(y,d2)))))
  surf: as~many

# - category: (S\NP)/NP
#   semantics: \E Q1 Q2. Q2(\w.True, \x.Q1(\w.True, \x.E(x)))
#   entity: PRE

# - category: (S[adj=true]\NP)/PP
#   # semantics: \E Q d. Q(\x. E(x,d))
#   semantics: \E d1 d2 d3 H Q. Q(\x.E(x,d1))
#   pos: JJ

# - category: (S\NP)\(S\NP)
#   # semantics: \E Q d. Q(\w.True, \x. E(x,d))
#   semantics: \E d1 d2 d3 H Q. Q(\w.True,\x.E(x,d1))
#   pos: JJ

##### Auxiliary verbs #####

- category: (S[dcl=true]\NP)/(S[b=true]\NP)
  # semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.E(F2(x))))
  semantics: \E V Q. Q(\w.True, \x.V(\F1 F2.(E(x) & F2(x))))

- category: (S[dcl=true]\NP)/(S[b=true]\NP)
  semantics: \E V. V
  base: do

- category: (S[dcl=true]\NP)/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.-(Q1(\w.True, \y.(x = y))))
  # semantics: \E Q1 Q2. -Q2(\w.True, \x.(Q1(\w.True, \y.(x = y))))
  surf: isn't

- category: (S[dcl=true]\NP)/NP
  semantics: \E Q1 Q2. Q2(\w.True, \x.-(Q1(\w.True, \y.(x = y))))
  # semantics: \E Q1 Q2. -Q2(\w.True, \x.(Q1(\w.True, \y.(x = y))))
  surf: aren't

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: isn't

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: aren't

- category: (S[dcl=true]\NP)/(S\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: don't

- category:  (S[dcl=true]\NP)/(S\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: doesn't

- category:  (S[dcl=true]\NP)/(S\NP)
  semantics: \E V Q. Q(\w.True, \x.-V(\F1 F2.F2(x)))
  # semantics: \E V Q. -Q(\w.True, \x.V(\F1 F2.F2(x)))
  surf: didn't


##### Floating quantifiers #####

- category: (S\NP)/(S\NP)
  semantics: \E V Q. forall x. (Q(\w.True, \y.(x = y)) -> V(\F1 F2.F2(x)))
  surf: all

- category: (S\NP)\(S\NP)
  semantics: \E V Q. forall x. (Q(\w.True, \y.(x = y)) -> V(\F1 F2.F2(x)))
  surf: all

- category: (S\NP)/(S\NP)
  semantics: \E V Q. forall x. (Q(\w.True, \y.(x = y)) -> V(\F1 F2.F2(x)))
  surf: each

- category: (S\NP)\(S\NP)
  semantics: \E V Q. forall x. (Q(\w.True, \y.(x = y)) -> V(\F1 F2.F2(x)))
  surf: each


##### Relative clauses #####

- category: (NP\NP)/(S[dcl=true]\NP)
  semantics: \E V Q F1. Q(\x. (V(\F2 F3. F3(x)) & F1(x)))

- category: NP/(S[dcl=true]/NP)
  semantics: \E V F1 F2. exists x. (V(\G1 G2.G2(x)) & F1(x) & F2(x))

- category: (NP\NP)/(S[dcl=true]/NP)
  semantics: \E V Q F1. Q(\x. (V(\F2 F3. F3(x)) & F1(x)))

- category: (N\N[adj=true])/(S[dcl=true]/NP)
  semantics: \E Q1 A F x.A(F,d1,d2,d3,I,J,\W.W(x),\W.exists y.Q1(\F1 F2.(W(y) & F2(y))),c)
  surf: than

##### Complementizers #####

- category: S[em=true]/S[dcl=true]
  semantics: \E X. X


##### Connectives #####

## default conjunctive interpretation
- category: (S/S)/S[dcl=true]
  semantics: \E S1 S2. (S1 & S2 & E(S1, S2))

- category: (S/S)/S[dcl=true]
  semantics: \E S1 S2. (S1 -> S2)
  surf: if

- category: (S/S)/S[dcl=true]
  semantics: \E S1 S2. (S1 -> S2)
  surf: before

- category: ((S\NP)\(S\NP))/S[dcl=true]
  semantics: \E S V Q. E(S, V(Q))

- category: ((S\NP)\(S\NP))/S[dcl=true]
  semantics: \E S V Q. E(S, V(Q))
  surf: after

- category: ((S\NP)\(S\NP))/S[dcl=true]
  semantics: \E S V Q. E(S, V(Q))
  surf: before

- category: (S/S)/S[dcl=true]
  semantics: \E S1 S2. (S1 -> S2)
  surf: when

- category: (S\NP)/(S\NP)
  semantics: \E V Q. V(Q)
  surf: either

- category : N/N
  semantics: \E X.X
  surf: either


##### Semantically empty expressions #####

- category: NP[thr=true]
  semantics: \E F1 F2. F2(E)
  # semantics: \E F1 F2. exists x.F2(x)

- category: (S[to=true]\NP)/(S[b=true]\NP)
  semantics: \E X. X

- category: S[asup=true]\NP
  semantics: \E X. X

- category: (S/S)/(S[asup=true]\NP)
  semantics: \E X Y. Y


##### Possesive particle #####
- category: (NP[nb=true]/N)\NP
  # semantics: \E Q F1 F2 F3. exists x.((Q(\w.True, \y.Rel(x, y)) & F1(x)) & F2(x) & F3(x))
  semantics: \E Q F1 F2 F3. exists x.((Q(\w.True, \y.Rel(x, y)) & F1(\w.True,x)) & F2(x) & F3(x))
  surf: "_'s"

- category: ((S[dcl=true]\NP[expl=true])/S[em=true])/(S[adj=true]\NP)
  # semantics: \E Q F1 F2 F3. exists x.((Q(\w.True, \y.Rel(x, y)) & F1(x)) & F2(x) & F3(x))
  semantics: \E A S Q.A(d1,d2,d3,H,I,J,\F1 F2.Q(F1,\x.F2(S)))
  surf: "_'s"

##### Sentence final particle #####

- category: .
  semantics: \S X. X
  surf: "."

- category: ","
  semantics: \S X. X
  surf: ","

### Numeral ###

- category: N/N
  semantics: \E. E
  pos: CD

# # - category: (((S\NP)\((S\NP)/NP))/N)/(((S\NP)\((S\NP)/NP))/N)
# - category: (NP[adj=true]/N)/(NP[adj=true]/N)
#   semantics: \E A N V d1 d2 H Q.A(N,V,$sum(d1,E),d2,H,Q)
#   pos: CD

- category: ((S[adj=true]\NP)/(S[adj=true]\NP))/((S[adj=true]\NP)/(S[adj=true]\NP))
  semantics: \E. E
  pos: CD

- category: ((((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N))/((((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N))
  semantics: \E. E
  pos: CD

- category: ((N/N)/(N/N))/((N/N)/(N/N))
  semantics: \E. E
  pos: CD

## multicative ##
- category: N/N
  semantics: \E d. $product(d,2)
  surf: twice

- category: (N/N)/(N/N)
  semantics: \E d. $product(d,2)
  surf: twice

- category: (N[adj=true]/N)/(N[adj=true]/N)
  semantics: \E A N1 F d1 d2 d3 I J W1 W2 c.all d1.exists c.A(N1,F,d1,$difference(d1,E),_2,\A1 A2 A3.(A2 -> A1),\w.True,W1,W2,c)
  pos: CD

- category: (S[adj=true]\NP)/(S[adj=true]\NP)
  semantics: \E A d1 d2 d3 H I J Q.exists d1.A($product(d1,2),d1,_th(_u),H,\A1 A2 A3 x.(A2 -> A1(x)),J,Q)
  surf: twice

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)
- category: (NP[adj=true]/N)/(NP[adj=true]/N)
  # semantics: \E A N V Q.all d1.exists c.A(N,V,$product(d1,2),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  semantics: \E A N V d1 d2 I c Q.all d1.exists c.A(N,V,$product(d1,2),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  surf: twice

# - category: (((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)/(((S[dcl=true]\NP)\((S[dcl=true]\NP)/NP))/N)
- category: (NP[adj=true]/N)/(NP[adj=true]/N)
  # semantics: \E A N V Q.all d1.exists c.A(N,V,$sum(d1,E),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  semantics: \E A N V d1 d2 I c Q.all d1.exists c.A(N,V,$sum(d1,E),d1,\A1 A2 z2 z1.(exists y.A2(y,z2) -> exists x.A1(x,z1)),c,Q)
  pos: CD

# sententce final particle
- category: S
  rule: rp
  semantics: \S D. S

- category: NP
  rule: rp
  semantics: \S D. S
